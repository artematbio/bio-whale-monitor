# Документация по скрипту `pool_analyzer.py` для ИИ-Агентов

## 1. Обзор

*   **Назначение скрипта:** Скрипт `pool_analyzer.py` предназначен для комплексного анализа CLMM (Concentrated Liquidity Market Maker) пулов на платформе Raydium в сети Solana. Он собирает данные о целевых пулах, анализирует позиции указанного кошелька в этих пулах, рассчитывает их USD-стоимость, объемы торгов, комиссии, и генерирует детальные отчеты в форматах JSON и TXT.
*   **Ключевые функции:**
    *   Анализ нескольких заданных CLMM пулов Raydium.
    *   Получение и анализ всех CLMM позиций целевого кошелька с использованием `positions.py`.
    *   Определение текущей цены токенов через API GeckoTerminal (основной источник) и CoinGecko (запасной).
    *   Расчет USD-стоимости активов и невостребованных комиссий для каждой позиции.
    *   Определение, находится ли позиция в текущем ценовом диапазоне.
    *   Сбор рыночных данных пулов: TVL, 24-часовой объем (из Raydium API).
    *   Сбор исторических данных по объемам торгов за 7 дней (из BitQuery API).
    *   Сбор детальной истории торгов за 7 дней (из BitQuery API).
    *   Получение метаданных токенов (символ, имя) через Helius API.
    *   Генерация сводного отчета в форматах JSON и удобочитаемом TXT.

## 2. Основная конфигурация и константы

*   **`PRIMARY_TARGET_POOL_IDS` (List[str]):** Список строковых идентификаторов (адресов) CLMM пулов Raydium, которые подлежат детальному анализу. Скрипт итерируется по этому списку, собирая и обрабатывая данные для каждого указанного пула. Определяется в начале скрипта на основе переменных `TARGET_POOL_ID_1` - `TARGET_POOL_ID_9`.
*   **API Ключи и URL:**
    *   Helius:
        *   `HELIUS_API_KEY` (str): API ключ для доступа к сервисам Helius (RPC, metadata).
        *   `HELIUS_RPC_URL` (str): URL для RPC запросов к Helius.
    *   CoinGecko:
        *   `COINGECKO_ENDPOINT` (str): Базовый URL для API CoinGecko (Pro).
        *   `COINGECKO_API_KEY` (str): API ключ для CoinGecko Pro (если используется).
    *   BitQuery:
        *   `BITQUERY_API_KEY` (str): API ключ для доступа к GraphQL API BitQuery.
        *   `BITQUERY_ENDPOINT` (str): URL для GraphQL запросов к BitQuery.
    *   Raydium API V3:
        *   `RAYDIUM_API_V3_BASE_URL` (str): Базовый URL для API V3 Raydium.
*   **`TARGET_WALLET_ADDRESS` (str):** Публичный ключ (адрес) Solana-кошелька, чьи CLMM позиции будут анализироваться.
*   **Словари токенов:**
    *   **`TOKEN_SYMBOL_MAP` (Dict[str, str]):** Словарь для сопоставления адресов токенов (ключ) с их тикерами/символами (значение). Используется для отображения символов в отчетах и логах, когда метаданные из API недоступны или для часто используемых токенов. *Пример: `"So11111111111111111111111111111111111111112": "SOL"`*
    *   **`TOKEN_COINGECKO_IDS` (Dict[str, str]):** Словарь для сопоставления адресов токенов (ключ) с их идентификаторами на CoinGecko (значение). Необходимо для запроса исторических цен и другой информации с CoinGecko. *Пример: `"bioJ9JTqW62MLz7UKHU69gtKhPpGi1BQhccj2kmSvUJ": "bio-protocol"`*
*   **Адреса ключевых токенов:** В скрипте определены константы для адресов часто используемых токенов, таких как `BIO_ADDRESS`, `MYCO_ADDRESS`, `SPINE_ADDRESS`. Это упрощает их использование в коде.

## 3. Поток данных и ключевые функции

#### 3.1. Стратегия получения цен токенов (КРИТИЧЕСКИ ВАЖНО)

*   **Основной источник текущих цен:** `fetch_token_prices_geckoterminal` (GeckoTerminal API).
    *   В начале функции `main()` происходит сбор всех уникальных адресов токенов из всех CLMM позиций кошелька.
    *   Затем для этого набора адресов ЕДИНОРАЗОВО запрашиваются цены через `fetch_token_prices_geckoterminal`.
    *   Эти цены сохраняются в `master_token_prices` и передаются во все последующие функции, которым требуются цены (например, `analyze_single_position`, `fetch_bitquery_pool_daily_volume_7d`).
    *   Если GeckoTerminal не возвращает цену для какого-либо токена, или возвращает 0, в `master_token_prices` для этого токена будет установлено значение `Decimal(0)`.
*   **Вторичный/Исторический источник:** `fetch_historical_token_price_coingecko` и `fetch_token_prices_coingecko` (CoinGecko API).
    *   CoinGecko используется в основном для получения *исторических* цен по дням в функции `fetch_bitquery_pool_daily_volume_7d`, если прямой USD объем от BitQuery равен нулю. Для этого требуется наличие токена в `TOKEN_COINGECKO_IDS`.
    *   Также CoinGecko может быть использован как запасной вариант для получения *текущей* цены в `fetch_raydium_pool_market_data`, если GeckoTerminal не вернул цену для `quote_token_mint` (при расчете 24ч объема, если `volumeUSD` и `volume` от Raydium API равны нулю). Опять же, требуется `TOKEN_COINGECKO_IDS`.
    *   В `main()` есть логика дополнительного запроса цен из CoinGecko (и затем снова из GeckoTerminal) для токенов, которые необходимы для расчета USD-объема в исторических данных BitQuery (`historical_trades_data_list`), если для них не нашлось цены в `master_token_prices`.
*   **Хранение и передача цен:**
    *   `master_token_prices` (Dict[str, Decimal]): Основной словарь, агрегирующий цены из GeckoTerminal (и потенциально обновленный из CoinGecko в специфичных случаях). Передается по всему коду.
    *   `token_price_sources` (Dict[str, str]): Отслеживает, из какого API была получена цена для каждого токена (например, "GeckoTerminal", "CoinGecko"). Используется для отладки и информации в отчетах (хотя в текущей версии текстового отчета не выводится).
*   **ПРЕДОСТЕРЕЖЕНИЕ:**
    *   Надежность и доступность API GeckoTerminal и CoinGecko напрямую влияют на точность всех USD-расчетов.
    *   Rate-limiting со стороны этих API может приводить к отсутствию цен и, как следствие, к нулевым USD-стоимостям/объемам.
    *   Отсутствие токена в `TOKEN_COINGECKO_IDS` ограничит возможность получения его исторической цены или использования CoinGecko как запасного варианта для текущей цены.

#### 3.2. Анализ позиций

*   **`positions.py::get_clmm_positions`**: Это **единственный источник данных** для первичного получения информации обо всех активных CLMM позициях целевого кошелька. 
    *   **Входные данные:** Адрес кошелька, URL Helius RPC, API ключ Helius.
    *   **Выходные данные:** Список словарей, где каждый словарь представляет одну CLMM позицию и содержит ключевую информацию, такую как:
        *   `position_mint` (адрес NFT позиции)
        *   `position_pda` (адрес аккаунта состояния позиции)
        *   `pool_id` (адрес CLMM пула)
        *   `pool_name` (например, "SOL/USDC")
        *   `token0` (адрес токена A)
        *   `token1` (адрес токена B)
        *   `amount0` (количество токена A, скорректированное на десятичные разряды)
        *   `amount1` (количество токена B, скорректированное на десятичные разряды)
        *   `position_value_usd` (общая USD-стоимость токенов в позиции, рассчитанная на основе цен из GeckoTerminal/CoinGecko, переданных в `get_clmm_positions`)
        *   `in_range` (boolean, находится ли позиция в текущем ценовом диапазоне пула)
        *   `unclaimed_fees_token0`, `unclaimed_fees_token1` (невостребованные комиссии в токенах A и B)
        *   `unclaimed_fees_total_usd_str` (общая USD-стоимость невостребованных комиссий)
        *   `pending_rewards_details` (информация о невостребованных наградах в других токенах)
        *   `fee_tier` (комиссионный уровень пула)
        *   `current_price` (текущая цена в пуле)
        *   И другие поля, необходимые для анализа.
    *   **Важно:** `pool_analyzer.py` полностью доверяет данным, возвращаемым этой функцией, особенно в части расчета `position_value_usd` и `unclaimed_fees`. `pool_analyzer.py` *не пересчитывает* эти значения самостоятельно для всех позиций, а использует их как есть, кроме случаев, когда он вызывает `analyze_single_position` для *основных целевых пулов*.
*   **`analyze_single_position`**: Эта функция используется в `pool_analyzer.py` для более глубокого (повторного) анализа позиций, которые принадлежат к списку `PRIMARY_TARGET_POOL_IDS`. 
    *   **Цель:** Получить наиболее актуальные данные по состоянию позиции и пула непосредственно из блокчейна и пересчитать стоимость токенов и комиссий, используя `master_token_prices`.
    *   **Входные данные:** NFT минт позиции, PDA позиции, ID целевого пула, предварительно загруженное ончейн-состояние *целевого* пула, `master_token_prices`, RPC URL, HTTP-клиент.
    *   **Процесс:**
        1.  Получает ончейн-данные аккаунта состояния позиции (PDA) через RPC (`get_account_info_via_httpx`, `POSITION_STATE_LAYOUT`).
        2.  Извлекает `poolId` из состояния позиции. 
        3.  **Проверка соответствия пула:** Если `poolId` из состояния позиции не совпадает с `target_pool_id` (т.е. позиция по факту принадлежит другому пулу, чем ожидалось), скрипт пытается загрузить ончейн-состояние *фактического* пула. Если это не удается, он использует состояние *целевого* пула как fallback (с предупреждением).
        4.  Используя актуальное ончейн-состояние пула (количество ликвидности, текущий тик, `sqrtPriceX64`, десятичные разряды токенов) и тики позиции (`tickLowerIndex`, `tickUpperIndex`), вызывает `calculate_token_amounts` для расчета *сырых* количеств токенов A и B.
        5.  Корректирует сырые количества на десятичные разряды.
        6.  Извлекает невостребованные комиссии (`tokenFeesOwedA`, `tokenFeesOwedB`) и корректирует их.
        7.  Рассчитывает USD-стоимость токенов и комиссий, используя цены из `master_token_prices`.
        8.  Определяет, находится ли позиция в диапазоне (`is_in_range`).
    *   **Выходные данные:** Словарь с детальной информацией о позиции, включая пересчитанные стоимости, количество токенов, комиссий и т.д. Эти данные затем обновляют информацию о позиции, полученную ранее из `get_clmm_positions` (только для позиций в `PRIMARY_TARGET_POOL_IDS`).

#### 3.3. Получение данных о пулах

*   **`fetch_raydium_pool_info` (Raydium API V3 - `/pools/info/ids`):** 
    *   **Назначение:** Получает общую информацию о пуле от Raydium, такую как тип, идентификаторы токенов, базовые метаданные токенов (адрес, символ, имя, десятичные разряды), текущую цену, TVL, данные по объемам и APR за день/неделю/месяц, конфигурацию пула.
    *   **Вход:** ID пула.
    *   **Выход:** Словарь с данными о пуле. Используется для получения общей картины, но для критических ончейн-данных (например, `tickCurrent`) используется `fetch_onchain_pool_state`.
    *   **Примечание:** Данные о `price`, `tvl`, `day.volume`, `day.volumeQuote` из этой функции используются в `fetch_raydium_pool_market_data`.
*   **`fetch_onchain_pool_state` (Helius RPC):**
    *   **Назначение:** Получает наиболее актуальное состояние CLMM пула непосредственно из блокчейна Solana.
    *   **Вход:** ID пула, RPC URL, HTTP-клиент.
    *   **Процесс:** Выполняет RPC запрос `getAccountInfo` к указанному ID пула, получает base64-закодированные данные аккаунта и парсит их с помощью `POOL_STATE_LAYOUT`.
    *   **Выход:** Словарь, содержащий ключевые ончейн-параметры пула:
        *   `tickCurrent` (текущий активный тик)
        *   `sqrtPriceX64` (текущая цена в формате sqrt(P) * 2^64)
        *   `liquidity` (текущая общая ликвидность пула)
        *   `tokenMint0`, `tokenMint1` (адреса токенов)
        *   `mintDecimals0`, `mintDecimals1` (десятичные разряды токенов)
        *   `ammConfig` (адрес конфигурации AMM пула, используется для получения `feeRate`)
        *   И другие поля из `POOL_STATE_LAYOUT`.
    *   **Важность:** Это основной источник для точных расчетов, связанных с позициями (`analyze_single_position`), так как содержит самые свежие данные из блокчейна.
*   **`fetch_raydium_pool_market_data` (Raydium API V3 - `/pools/info/ids`):**
    *   **Назначение:** Специализированная функция для получения TVL и 24-часового объема торгов в USD для указанного пула.
    *   **Вход:** ID пула.
    *   **Процесс:** 
        1.  Обращается к Raydium API (тому же эндпоинту, что и `fetch_raydium_pool_info`).
        2.  Извлекает `tvl`.
        3.  Для 24ч объема последовательно проверяет наличие и значение полей в ответе API:
            а. `day.volumeUSD` (прямой USD объем).
            б. `day.volume` (предполагается, что это USD объем, если `volumeUSD` отсутствует/ноль).
            в. `day.volumeQuote` (объем в quote-токене). Если используется это поле, то дополнительно запрашивается цена quote-токена (сначала GeckoTerminal, затем CoinGecko как fallback), чтобы конвертировать объем в USD.
    *   **Выход:** Словарь с `pool_tvl_usd` и `pool_24h_volume_usd`.
*   **`fetch_bitquery_pool_daily_volume_7d` (BitQuery API):**
    *   **Назначение:** Получает агрегированные данные по дневному объему торгов за последние 7 дней для указанной пары токенов.
    *   **Вход:** Адреса токенов A и B, `master_token_prices` (для возможного расчета USD на основе исторической цены базового токена), HTTP-клиент.
    *   **Процесс:**
        1.  Определяет, какой из токенов пары будет `base` (обычно SOL или стейблкоин), а какой `token` для GraphQL запроса BitQuery.
        2.  Для каждого из последних 7 дней формирует GraphQL запрос к `Solana.DEXTradeByTokens`.
        3.  Запрос агрегирует `sum(of: Trade_Side_AmountInUSD)` (прямой USD объем) и `sum(of: Trade_Side_Amount)` (объем в `base` токене).
        4.  Если `daily_usd_volume` из BitQuery > 0, используется это значение.
        5.  Если `daily_usd_volume` == 0, но `volume` (в `base` токене) > 0, скрипт пытается рассчитать USD-объем:
            а. Пытается получить *историческую* цену `base` токена на соответствующий день через CoinGecko (требуется `TOKEN_COINGECKO_IDS`).
            б. Если историческая цена не найдена, использует *текущую* цену `base` токена из `master_token_prices`.
            в. Умножает объем в `base` токене на найденную цену.
    *   **Выход:** Список словарей, где каждый словарь представляет один день и содержит `date`, `daily_usd_volume`, `volume` (в `base` токене), `trades` (количество сделок), `source` (источник данных для USD объема: `direct_from_api`, `historical_price_COINGECKO_ID`, `calculated_from_current_price` и т.д.).
*   **`fetch_bitquery_trade_history` (BitQuery API):**
    *   **Назначение:** Получает *детальную* историю агрегированных сделок (не отдельных транзакций, а агрегированных данных по временным интервалам или блокам, в зависимости от ответа BitQuery) для пары токенов за указанное количество дней.
    *   **Вход:** Адреса токенов A и B, количество дней, HTTP-клиент.
    *   **GraphQL запрос:** Использует `Solana.DEXTradeByTokens` с полями `trades` (count), `volume` (sum of `Trade_Side_Amount`), `usd_volume` (sum of `Trade_Side_AmountInUSD`), `buy_volume`, `sell_volume`, `Block.Time`, и информацию о токенах и DEX.
    *   **Обработка USD объема:** В `main()` после получения этих данных, если `usd_volume` в записи равен 0 или отсутствует, а `volume` (в базовом токене записи) > 0, то делается попытка рассчитать USD-объем, используя цены из `master_token_prices` (с дополнительным подтягиванием цен из CoinGecko/GeckoTerminal, если необходимо).
    *   **Выход:** Список словарей, представляющих агрегированные данные о торгах. Используется для расчета сводной 7-дневной статистики в отчете.

#### 3.4. Метаданные токенов

*   **`fetch_helius_token_metadata` (Helius API - `/v0/token-metadata`):**
    *   **Назначение:** Получает метаданные для списка адресов токенов, такие как символ и имя токена.
    *   **Вход:** Список адресов токенов (mint addresses).
    *   **Процесс:** Отправляет POST-запрос к Helius API с указанными адресами.
    *   **Выход:** Словарь, где ключами являются адреса токенов, а значениями — словари с полями `symbol` и `name`.
    *   **Использование:** Хотя эта функция присутствует, в текущей основной логике `main()` она **не вызывается явно** для обогащения данных о токенах в отчете. Символы и имена токенов в основном берутся из:
        1.  `TOKEN_SYMBOL_MAP` (локальный маппинг).
        2.  Данных, возвращаемых `positions.py::get_clmm_positions` (которые, в свою очередь, могут получать их из Helius или других источников).
        3.  Данных из `fetch_raydium_pool_info` (Raydium API).
    *   **Примечание:** Эта функция может быть полезна, если потребуется принудительно обновить или получить метаданные для токенов, информация о которых отсутствует в других источниках или в `TOKEN_SYMBOL_MAP`.

## 4. Ключевые расчеты и логика

*   **CLMM Математика:**
    *   **`tick_to_sqrt_price_x64(tick: int) -> Decimal`**:
        *   **Назначение:** Конвертирует индекс тика в значение `sqrtPriceX64` (квадратный корень из цены, умноженный на 2^64). Это стандартная формула для CLMM.
        *   **Формула:** `Decimal(1.0001) ** Decimal(tick) * Decimal(2**64)`.
        *   **Использование:** Применяется в `calculate_token_amounts` для получения `sqrtPriceA` и `sqrtPriceB` (значения `sqrtPriceX64` для нижнего и верхнего тиков позиции).
    *   **`calculate_token_amounts(liquidity: int, sqrt_price_x64_current: Decimal, sqrt_price_x64_lower: Decimal, sqrt_price_x64_upper: Decimal, token_0_decimals: int, token_1_decimals: int) -> Tuple[Decimal, Decimal]`**:
        *   **Назначение:** Рассчитывает количество токенов A (token0) и B (token1) для заданной ликвидности (`L`) и ценового диапазона (определяемого `sqrt_price_x64_lower` и `sqrt_price_x64_upper`) относительно текущей цены (`sqrt_price_x64_current`).
        *   **Логика (основана на формулах Uniswap V3 / Raydium CLMM):**
            *   Если текущая цена (`sqrt_price_x64_current`) **ниже** диапазона (`sqrt_price_x64_current < sqrt_price_x64_lower`):
                *   Вся ликвидность состоит из токена A.
                *   `amount0_raw = liquidity * (sqrt_price_x64_upper - sqrt_price_x64_lower) / (sqrt_price_x64_upper * sqrt_price_x64_lower / Decimal(2**64))`
                *   `amount1_raw = 0`
            *   Если текущая цена (`sqrt_price_x64_current`) **выше** диапазона (`sqrt_price_x64_current > sqrt_price_x64_upper`):
                *   Вся ликвидность состоит из токена B.
                *   `amount0_raw = 0`
                *   `amount1_raw = liquidity * (sqrt_price_x64_upper - sqrt_price_x64_lower) / Decimal(2**64)`
            *   Если текущая цена **внутри** диапазона (`sqrt_price_x64_lower <= sqrt_price_x64_current <= sqrt_price_x64_upper`):
                *   Ликвидность состоит из обоих токенов.
                *   `amount0_raw = liquidity * (sqrt_price_x64_upper - sqrt_price_x64_current) / (sqrt_price_x64_upper * sqrt_price_x64_current / Decimal(2**64))`
                *   `amount1_raw = liquidity * (sqrt_price_x64_current - sqrt_price_x64_lower) / Decimal(2**64)`
        *   **Коррекция на десятичные разряды:** Полученные `amount0_raw` и `amount1_raw` затем делятся на `10 ** token_0_decimals` и `10 ** token_1_decimals` соответственно для получения реального количества токенов.
        *   **Использование:** Ключевая функция для определения состава активов в CLMM позиции в `analyze_single_position`.
*   **Расчет USD-стоимости:**
    *   **Позиции:**
        *   **Основной расчет (в `analyze_single_position`):**
            *   `token0_amount_usd = token0_amount * master_token_prices.get(token0_mint, Decimal(0))`
            *   `token1_amount_usd = token1_amount * master_token_prices.get(token1_mint, Decimal(0))`
            *   `total_position_value_usd = token0_amount_usd + token1_amount_usd`
        *   **Невостребованные комиссии (в `analyze_single_position`):** Аналогично, количество каждого токена в комиссиях умножается на его цену из `master_token_prices`.
            *   `unclaimed_fees_token0_usd = unclaimed_fees_token0_adjusted * master_token_prices.get(token0_mint, Decimal(0))`
            *   `unclaimed_fees_token1_usd = unclaimed_fees_token1_adjusted * master_token_prices.get(token1_mint, Decimal(0))`
            *   `total_unclaimed_fees_usd = unclaimed_fees_token0_usd + unclaimed_fees_token1_usd`
        *   **Данные из `positions.py::get_clmm_positions`:** Как упомянуто, `pool_analyzer.py` использует USD-стоимости, уже рассчитанные в `positions.py` для всех позиций, не входящих в `PRIMARY_TARGET_POOL_IDS`. Предполагается, что `positions.py` использует аналогичную логику с переданными ему ценами.
    *   **Объемы торгов:**
        *   **24-часовой объем (в `fetch_raydium_pool_market_data`):**
            *   Если Raydium API возвращает `day.volumeUSD > 0`, используется это значение.
            *   Если `day.volumeUSD == 0`, но `day.volume > 0`, используется `day.volume` (предполагается, что это USD).
            *   Если оба вышеуказанных поля отсутствуют или равны нулю, используется `day.volumeQuote`. Цена `quote_token_mint` запрашивается (GeckoTerminal, затем CoinGecko fallback), и `pool_24h_volume_usd = day_volume_quote * quote_token_price`.
        *   **Дневные объемы за 7 дней (в `fetch_bitquery_pool_daily_volume_7d`):**
            *   Если BitQuery API возвращает `daily_usd_volume > 0`, используется это значение.
            *   Если `daily_usd_volume == 0`, но `volume_in_base_token > 0` (название поля уточнено для ясности), скрипт пытается рассчитать USD-объем:
                а. Пытается получить *историческую* цену `base_token` на соответствующий день через CoinGecko.
                б. Если историческая цена не найдена, использует *текущую* цену `base_token` из `master_token_prices`.
                в. Умножает объем в `base_token` на найденную цену.

#### 4.3. Определение нахождения позиции в диапазоне (`is_in_range`)

*   **Назначение:** Определить, активна ли ликвидность CLMM позиции в данный момент, то есть находится ли текущая цена пула (`tickCurrent`) внутри диапазона, заданного тиками позиции (`tickLowerIndex`, `tickUpperIndex`).
*   **Логика:**
    *   В функции `analyze_single_position`:
        1.  Получает `tickLowerIndex` и `tickUpperIndex` из ончейн-состояния позиции.
        2.  Получает `tickCurrent` из ончейн-состояния пула.
        3.  Сравнивает: `is_in_range = tickLowerIndex <= tickCurrent < tickUpperIndex`.
        *   **Важно:** Верхняя граница (`tickUpperIndex`) не включается в диапазон, так как ликвидность активна *до* этого тика.
    *   В `positions.py::get_clmm_positions`:
        *   Эта функция также возвращает флаг `in_range`. Предполагается, что она использует аналогичную логику, сравнивая текущий тик пула с тиками позиции.
*   **Использование:**
    *   Значение `is_in_range` используется для информирования пользователя о состоянии его позиций.
    *   Позиции вне диапазона не генерируют комиссии.
    *   В отчетах часто указывается, находится ли позиция в диапазоне.

## 5. Отчеты (Reports)

#### 5.1. JSON отчет (`pool_report.json`)

*   **Назначение:** Предоставляет структурированные данные анализа в формате JSON, пригодном для машинной обработки или интеграции с другими системами.
*   **Местоположение файла:** Генерируется в том же каталоге, где запущен скрипт.
*   **Структура верхнего уровня:**
    *   `report_generation_date_utc` (str): Дата и время генерации отчета в UTC.
    *   `report_update_date_utc` (str): Дата и время последнего обновления данных в отчете (если отчет дописывается).
    *   `target_wallet` (str): Анализируемый Solana-кошелек.
    *   `pools_data` (Dict[str, Dict]): Словарь, где ключами являются ID пулов. Каждое значение — это словарь с данными по конкретному пулу.
    *   `wallet_positions_summary` (Dict): Сводная информация по всем позициям кошелька (не только в `PRIMARY_TARGET_POOL_IDS`):
        *   `total_positions_value_usd` (str): Общая USD-стоимость всех CLMM позиций.
        *   `total_unclaimed_fees_usd` (str): Общая USD-стоимость всех невостребованных комиссий.
        *   `positions_count` (int): Общее количество CLMM позиций.
    *   `all_positions_detailed` (List[Dict]): Список словарей, где каждый словарь представляет детальную информацию по одной CLMM позиции кошелька (данные из `positions.py::get_clmm_positions` с возможными обновлениями из `analyze_single_position`).
*   **Структура данных для каждого пула в `pools_data`:**
    *   `pool_id` (str): ID пула.
    *   `pool_name` (str): Имя пула (например, "SOL/USDC").
    *   `current_price_in_pool` (str): Текущая цена в пуле (token1 per token0).
    *   `pool_tvl_usd` (str): Общий TVL пула в USD.
    *   `pool_24h_volume_usd` (str): Объем торгов в пуле за 24 часа в USD.
    *   `daily_volume_summary_7d` (List[Dict]): Список дневных объемов за 7 дней (из `fetch_bitquery_pool_daily_volume_7d`).
        *   Каждый элемент: `date`, `daily_usd_volume`, `volume` (в base токене), `trades`, `source`.
    *   `historical_trades_summary_7d` (Dict): Сводка по историческим торгам за 7 дней.
        *   `total_volume_usd` (str): Общий USD объем за 7 дней.
        *   `total_trades` (int): Общее количество сделок.
        *   `average_daily_volume_usd` (str): Среднедневной USD объем.
    *   `positions_in_this_pool` (List[Dict]): Список позиций кошелька, которые находятся в данном пуле. Структура каждого элемента аналогична `all_positions_detailed`.
    *   `token0_symbol`, `token1_symbol` (str): Символы токенов пула.
    *   `token0_address`, `token1_address` (str): Адреса токенов пула.
*   **Структура данных для каждой позиции в `all_positions_detailed` (и `positions_in_this_pool`):**
    *   `position_nft_mint` (str): Mint адрес NFT позиции.
    *   `position_pda` (str): Адрес PDA состояния позиции.
    *   `pool_id` (str): ID пула, к которому относится позиция.
    *   `pool_name` (str): Имя пула.
    *   `token0_symbol`, `token1_symbol` (str): Символы токенов.
    *   `token0_address`, `token1_address` (str): Адреса токенов.
    *   `price_lower`, `price_upper` (str): Нижняя и верхняя цены диапазона позиции.
    *   `current_price_in_pool` (str): Текущая цена в пуле.
    *   `is_in_range` (bool): Находится ли позиция в диапазоне.
    *   `token0_amount_human`, `token1_amount_human` (str): Количество токенов 0 и 1 в позиции.
    *   `token0_amount_usd`, `token1_amount_usd` (str): USD-стоимость токенов 0 и 1.
    *   `total_position_value_usd` (str): Общая USD-стоимость позиции.
    *   `unclaimed_fees_token0_human`, `unclaimed_fees_token1_human` (str): Количество невостребованных комиссий в токенах 0 и 1.
    *   `unclaimed_fees_token0_usd`, `unclaimed_fees_token1_usd` (str): USD-стоимость невостребованных комиссий.
    *   `total_unclaimed_fees_usd` (str): Общая USD-стоимость невостребованных комиссий.
    *   `raw_liquidity` (str): "Сырое" значение ликвидности позиции.
    *   Дополнительные поля из `positions.py` могут присутствовать.

#### 5.2. Текстовый отчет (`pool_report.txt`)

*   **Назначение:** Предоставляет удобочитаемый сводный отчет для пользователя, агрегируя ключевую информацию из JSON-отчета. Форматирован для удобного просмотра в текстовом редакторе или консоли.
*   **Местоположение файла:** Генерируется в том же каталоге, где запущен скрипт.
*   **Генерация:** Создается функцией `generate_text_report` на основе данных из `full_report_data` (которое является Python словарем, используемым для генерации JSON отчета).
*   **Обновление:** Если файл `pool_report.txt` уже существует, скрипт пытается обновить его, добавляя новую секцию с текущей датой формирования отчета. Старые данные остаются в файле для истории, но отделяются.
*   **Ключевые секции и информация:**
    *   **Заголовок:**
        *   `Дата формирования отчета (UTC)`: Время создания текущей секции отчета.
        *   `Целевой кошелек`: Адрес анализируемого кошелька.
    *   **Сводка по всем CLMM позициям кошелька:**
        *   Общее количество позиций.
        *   Общая USD-стоимость всех активов в позициях.
        *   Общая USD-стоимость всех невостребованных комиссий.
    *   **Детализация по каждому `PRIMARY_TARGET_POOL_ID`:**
        *   **Информация о пуле:**
            *   Название и ID пула.
            *   Символы токенов (например, SOL/USDC).
            *   Текущая цена в пуле.
            *   TVL (USD).
            *   Объем за 24ч (USD).
        *   **Позиции кошелька в данном пуле:**
            *   Для каждой позиции:
                *   ID NFT позиции.
                *   Статус: "В диапазоне" / "ВНЕ диапазона".
                *   Ценовой диапазон (в терминах обоих токенов).
                *   Состав активов: количество Token0 (USD), количество Token1 (USD).
                *   Общая стоимость активов в позиции (USD).
                *   Невостребованные комиссии: количество Token0 (USD), количество Token1 (USD).
                *   Общая стоимость невостребованных комиссий (USD).
        *   **Сводка по позициям в данном пуле:**
            *   Общая стоимость активов во всех позициях в этом пуле.
            *   Общая стоимость комиссий во всех позициях в этом пуле.
        *   **Данные по объемам торгов в пуле (за 7 дней):**
            *   Ежедневный объем торгов в USD.
            *   Источник данных для расчета USD объема (если не прямой от API).
        *   **Сводка по торгам за 7 дней:**
            *   Общий объем торгов (USD).
            *   Среднедневной объем (USD).
            *   Общее количество сделок.
    *   **Список всех позиций кошелька (сокращенный):**
        *   Для каждой позиции (не только в `PRIMARY_TARGET_POOL_IDS`):
            *   ID пула и название.
            *   USD-стоимость позиции.
            *   USD-стоимость невостребованных комиссий.
            *   Статус "В диапазоне" / "ВНЕ диапазона".
*   **Форматирование:** Используются отступы, разделители и заголовки для улучшения читаемости. Числовые значения (особенно USD) форматируются для наглядности.

## 6. Обработка ошибок и запасные варианты (Error Handling and Fallbacks)

*   **Общий подход:** Скрипт стремится быть устойчивым к временным сбоям API и отсутствию некоторых данных, используя комбинацию `try-except` блоков, логирования ошибок, и предоставления частичных результатов там, где это возможно.

*   **Обработка ошибок API запросов:**
    *   **`requests.exceptions.RequestException` (и его подклассы как `HTTPError`, `ConnectionError`, `Timeout`):**
        *   Все ключевые функции, взаимодействующие с внешними API (`fetch_token_prices_geckoterminal`, `fetch_token_prices_coingecko`, `fetch_raydium_pool_market_data`, `fetch_bitquery_pool_daily_volume_7d`, `fetch_bitquery_trade_history`, `fetch_helius_token_metadata`, `get_account_info_via_httpx`), обернуты в `try-except` блоки для перехвата этих исключений.
        *   При возникновении ошибки API запроса:
            *   Ошибка логируется с указанием URL и типа ошибки.
            *   Функция обычно возвращает `None`, пустой словарь/список или значение по умолчанию (например, `Decimal(0)` для цен или объемов), чтобы вызывающий код мог продолжить работу с частичными данными.
            *   Например, если `fetch_token_prices_geckoterminal` не может получить цены, `master_token_prices` останется неполным, и последующие расчеты USD-стоимости для этих токенов дадут 0.
    *   **Специфичные для API ошибки (например, BitQuery GraphQL ошибки):**
        *   Функции, работающие с BitQuery, проверяют наличие ключа `"errors"` в ответе JSON. Если ошибки присутствуют, они логируются.

*   **Отсутствие цен на токены:**
    *   **GeckoTerminal (`fetch_token_prices_geckoterminal`):** Если цена не найдена или равна 0, для токена в `master_token_prices` устанавливается `Decimal(0)`.
    *   **CoinGecko (`fetch_token_prices_coingecko`, `fetch_historical_token_price_coingecko`):** 
        *   Если токен не найден в `TOKEN_COINGECKO_IDS`, запрос не выполняется.
        *   Если API не возвращает цену, возвращается `Decimal(0)` или `None`.
        *   **Последствия:** Если цена токена неизвестна (`Decimal(0)`):
            *   USD-стоимость активов/комиссий для этого токена будет 0.
            *   Расчет USD-объема, если он зависит от цены этого токена, будет 0 или неточным.
            *   В текстовом отчете может быть секция, указывающая на токены, для которых не удалось получить цены (хотя в текущей реализации это не всегда явно выделяется).
        *   **Fallback стратегия для цен:**
            *   В `fetch_raydium_pool_market_data`: если `volumeUSD` и `volume` из Raydium API равны нулю, и для расчета USD-объема на основе `volumeQuote` требуется цена quote-токена, сначала делается попытка получить ее из GeckoTerminal (через `master_token_prices`), затем из CoinGecko.
            *   В `fetch_bitquery_pool_daily_volume_7d`: если прямой USD-объем от BitQuery равен нулю, но есть объем в базовом токене, делается попытка получить историческую цену базового токена из CoinGecko. Если это не удается, используется *текущая* цена из `master_token_prices`.
            *   В `main` при обработке `historical_trades_data_list`: если `usd_volume` равен нулю, а `volume` (в базовом токене) > 0, делается попытка рассчитать USD-объем, используя `master_token_prices`. Если цена на нужный токен отсутствует в `master_token_prices`, происходит дополнительный раунд запросов цен через CoinGecko и GeckoTerminal.

*   **Неконсистентность данных:**
    *   **`analyze_single_position` - несоответствие ID пула:** Если `poolId` из ончейн-состояния позиции не совпадает с `target_pool_id` (ID пула, для которого изначально анализировалась позиция), скрипт:
        1.  Логирует предупреждение.
        2.  Пытается загрузить ончейн-состояние *фактического* пула.
        3.  Если загрузка фактического состояния пула не удается, используется состояние *целевого* пула как fallback (с дополнительным предупреждением), что может привести к неточным расчетам для этой конкретной позиции.

*   **Пустые или неожиданные данные от API:**
    *   **Raydium API (`fetch_raydium_pool_market_data`):** Если поля `volumeUSD`, `volume`, `volumeQuote` отсутствуют или равны нулю, `pool_24h_volume_usd` будет `Decimal(0)`.
    *   **BitQuery API (`fetch_bitquery_pool_daily_volume_7d`, `fetch_bitquery_trade_history`):** Если API возвращает пустой список сделок или `null` для объемов, соответствующие метрики в отчете будут нулевыми.
    *   Скрипт в целом спроектирован так, чтобы продолжать работу, даже если часть данных отсутствует, отображая 0 или пропуская соответствующие разделы в отчете.

*   **Тайм-ауты:**
    *   Константа `HTTP_TIMEOUT_SECONDS` (по умолчанию 10 секунд) используется для всех HTTP-запросов, чтобы предотвратить зависание скрипта на длительное время.

*   **Логирование:**
    *   Скрипт использует модуль `logging` для записи информационных сообщений, предупреждений и ошибок. Уровень логирования по умолчанию INFO.
    *   Логи помогают отслеживать ход выполнения и диагностировать проблемы.

*   **Отсутствие `positions.py` или ошибки в нем:**
    *   Если `get_clmm_positions` из `positions.py` не может быть импортирован или вызывает исключение, основная часть анализа позиций не будет выполнена. Скрипт попытается продолжить с анализом пулов, но данные о позициях кошелька будут отсутствовать.

## 7. Руководство по внесению изменений для ИИ-Агентов

*   **Общие принципы:**
    *   **Контекст:** Прежде чем вносить изменения, убедитесь, что вы понимаете текущую задачу и как предлагаемое изменение вписывается в общую логику скрипта. Используйте эту документацию.
    *   **Изолированность:** Старайтесь вносить изменения точечно, затрагивая минимально необходимое количество функций или строк кода.
    *   **Тестирование (концептуальное):** Продумайте, как ваше изменение повлияет на поток данных и конечный результат (отчеты). Если возможно, предложите пользователю проверить ключевые аспекты после применения изменений.
    *   **Обратная совместимость:** Если изменяется структура отчета или ключевые поля, это может повлиять на системы, которые могут его потреблять. Учитывайте это.

*   **Частые задачи и как их выполнять:**
    *   **Изменение/добавление целевых пулов (`PRIMARY_TARGET_POOL_IDS`):**
        *   Измените значения строковых констант `TARGET_POOL_ID_1`, `TARGET_POOL_ID_2` и т.д. в начале скрипта.
        *   Убедитесь, что адреса пулов корректны.
    *   **Обновление API ключей:**
        *   Найдите соответствующие константы (`HELIUS_API_KEY`, `COINGECKO_API_KEY`, `BITQUERY_API_KEY`) и обновите их значения.
    *   **Изменение адреса целевого кошелька:**
        *   Обновите константу `TARGET_WALLET_ADDRESS`.
    *   **Добавление/обновление информации о токенах:**
        *   Для маппинга адреса на символ: измените `TOKEN_SYMBOL_MAP`.
        *   Для маппинга адреса на CoinGecko ID (для исторических цен/fallback): измените `TOKEN_COINGECKO_IDS`.
        *   Убедитесь, что CoinGecko ID корректен и активен.
    *   **Корректировка логики расчета USD (например, для объемов):**
        *   Наиболее вероятно, изменения потребуются в `fetch_raydium_pool_market_data` (для 24ч объема) или в `fetch_bitquery_pool_daily_volume_7d` / `main` (для 7-дневных объемов).
        *   Обращайте внимание на порядок использования полей (`volumeUSD`, `volume`, `volumeQuote`) и на логику получения цен токенов (`master_token_prices`, GeckoTerminal, CoinGecko).

*   **Ключевые структуры данных, которые нужно понимать:**
    *   **`master_token_prices` (Dict[str, Decimal]):** Центральное хранилище текущих цен токенов. Заполняется в `main()` в основном из `fetch_token_prices_geckoterminal`. Если вы меняете логику получения цен, убедитесь, что эта структура корректно обновляется.
    *   **`full_report_data` (Dict):** Python-словарь, который содержит все данные для генерации JSON и текстового отчета. Его структура подробно описана в Разделе 5.1. Изменения в логике сбора данных должны корректно отражаться здесь.
    *   **Объекты состояния позиции и пула:** Понимайте, какие данные приходят из `positions.py::get_clmm_positions`, `fetch_onchain_pool_state`, `analyze_single_position`.

*   **Что следует избегать:**
    *   **Жесткое кодирование динамических значений:** Не кодируйте цены, объемы или другие данные, которые должны получаться из API или расчетов, непосредственно в коде.
    *   **Изменение основных математических формул CLMM** (`tick_to_sqrt_price_x64`, `calculate_token_amounts`) без глубокого понимания их работы и последствий.
    *   **Удаление или изменение существующих полей в отчетах без явного запроса:** Это может нарушить ожидания пользователя или внешние интеграции.
    *   **Внесение не протестированных изменений в логику получения цен:** Ценообразование критично для всего скрипта.

*   **При возникновении проблем после изменений:**
    *   Проверьте логи на наличие ошибок или предупреждений.
    *   Попросите пользователя предоставить вывод скрипта и сгенерированные отчеты.
    *   Будьте готовы откатить изменения или предложить исправления.

*   **Формат запросов на изменения:**
    *   Четко формулируйте, *что* нужно изменить и *почему*.
    *   Если возможно, укажите конкретные функции или строки кода, которые, по вашему мнению, требуют модификации.
    *   Предоставляйте примеры данных или ожидаемого поведения, если это применимо.

*   **Важные константы и их роль (кратко):**
    *   `TARGET_POOL_ID_X`: Определяют целевые пулы для детального анализа.
    *   `TARGET_WALLET_ADDRESS`: Кошелек для анализа позиций.
    *   `TOKEN_SYMBOL_MAP`, `TOKEN_COINGECKO_IDS`: Для метаданных и цен токенов.
    *   API ключи: Для доступа к внешним сервисам.
    *   `HTTP_TIMEOUT_SECONDS`: Контролирует время ожидания HTTP-запросов.

Помните, что `pool_analyzer.py` взаимодействует с несколькими внешними API и блокчейн-данными, которые могут изменяться. Устойчивость к ошибкам и гибкость важны.

## 8. Известные проблемы и TODO

*   **Известные проблемы:**
    *   На данный момент не выявлено критических известных проблем, препятствующих основной функциональности скрипта.

*   **Потенциальные улучшения и TODO:**
    *   **Более явное уведомление о токенах без цен:** В текстовом отчете (`pool_report.txt`) можно улучшить секцию или механизм уведомления о токенах, для которых не удалось получить цены, с указанием, где именно эта цена требовалась (например, для расчета стоимости позиции X, для USD-конвертации объема в пуле Y). (См. Раздел 6)
    *   **Активное использование `fetch_helius_token_metadata`:** Рассмотреть возможность более активного использования `fetch_helius_token_metadata` в качестве запасного варианта, если символы/имена токенов не получены из `TOKEN_SYMBOL_MAP`, `positions.py` или `fetch_raydium_pool_info`. (См. Раздел 3.4)
    *   **Зависимость от `positions.py`:** Отчетность и анализ позиций сильно зависят от корректной работы и полноты данных, возвращаемых `positions.py`. Проблемы в `positions.py` напрямую повлияют на результаты `pool_analyzer.py`. Возможно, стоит добавить больше проверок на полноту данных от `positions.py`.
    *   **Гибкая настройка периода для исторических данных:** В настоящее время период для запроса исторических объемов (BitQuery) и сделок жестко задан (например, 7 дней). Рассмотреть возможность сделать это настраиваемым параметром.
    *   **Кэширование ответов API:** Для уменьшения количества запросов к внешним API (особенно для метаданных токенов или информации о пулах, которая не меняется часто) можно реализовать механизм кэширования с настраиваемым временем жизни кэша.
    *   **Визуализация данных:** В будущем можно рассмотреть возможность добавления генерации простых графиков или диаграмм для визуализации динамики объемов или распределения активов (потребует дополнительных библиотек).
    *   **Расширенный анализ APR/доходности:** Текущий скрипт фокусируется на состоянии и объемах. Можно расширить анализ, включив расчеты APR позиций на основе собранных комиссий и их стоимости за период.

**Заключительное примечание:** Данная документация была создана и обновлялась совместно с ИИ-ассистентом. При дальнейших модификациях скрипта не забывайте поддерживать актуальность этого документа. 